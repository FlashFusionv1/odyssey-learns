# API Integration Guide

## Overview
This guide documents how to integrate with the Supabase backend (Lovable Cloud) in Inner Odyssey, including query patterns, error handling, real-time subscriptions, and best practices.

**Backend:** Lovable Cloud (Supabase)  
**Client Library:** @supabase/supabase-js v2.75.0  
**State Management:** TanStack Query (React Query) v5.83.0  
**TypeScript Types:** Auto-generated from database schema

---

## Supabase Client Setup

### Pre-configured Client
**Location:** `src/integrations/supabase/client.ts`

```typescript
import { supabase } from '@/integrations/supabase/client';

// ⚠️ NEVER EDIT THIS FILE - Auto-generated by Lovable
```

**Configuration:**
```typescript
{
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
  }
}
```

**Environment Variables:**
- `VITE_SUPABASE_URL` - Auto-configured
- `VITE_SUPABASE_PUBLISHABLE_KEY` - Auto-configured

---

## TypeScript Types

### Auto-generated Types
**Location:** `src/integrations/supabase/types.ts`

```typescript
import type { Database } from '@/integrations/supabase/types';

// ⚠️ NEVER EDIT THIS FILE - Auto-generated from DB schema

// Access table types
type Child = Database['public']['Tables']['children']['Row'];
type Lesson = Database['public']['Tables']['lessons']['Row'];

// Access insert types
type ChildInsert = Database['public']['Tables']['children']['Insert'];

// Access update types
type ChildUpdate = Database['public']['Tables']['children']['Update'];
```

**Types Regenerate Automatically:**
- After database migrations
- When tables/columns change
- When RLS policies update

---

## Query Patterns

### Basic SELECT Query

```typescript
const { data, error } = await supabase
  .from('lessons')
  .select('*')
  .eq('grade_level', 2)
  .eq('is_active', true);

if (error) {
  console.error('Query error:', error);
  return;
}

console.log('Lessons:', data);
```

---

### SELECT with Specific Columns

```typescript
// ✅ BEST PRACTICE: Only fetch needed columns
const { data } = await supabase
  .from('lessons')
  .select('id, title, subject, estimated_minutes')
  .eq('grade_level', 2);
```

---

### SELECT with Joins

```typescript
// Join children with their parent profile
const { data } = await supabase
  .from('children')
  .select(`
    id,
    name,
    grade_level,
    profiles:parent_id (
      full_name,
      avatar_url
    )
  `)
  .eq('parent_id', userId);
```

---

### SELECT with Filtering

```typescript
// Multiple filters
const { data } = await supabase
  .from('user_progress')
  .select('*')
  .eq('child_id', childId)
  .eq('status', 'completed')
  .gte('completed_at', startDate)
  .lte('completed_at', endDate)
  .order('completed_at', { ascending: false })
  .limit(10);
```

**Available Operators:**
- `eq(column, value)` - Equal
- `neq(column, value)` - Not equal
- `gt(column, value)` - Greater than
- `gte(column, value)` - Greater than or equal
- `lt(column, value)` - Less than
- `lte(column, value)` - Less than or equal
- `like(column, pattern)` - Pattern match (case-sensitive)
- `ilike(column, pattern)` - Pattern match (case-insensitive)
- `in(column, array)` - In array
- `is(column, null)` - Is null
- `not(column, operator, value)` - Negate condition

---

### SELECT Single Row

```typescript
// Use .maybeSingle() when row might not exist
const { data, error } = await supabase
  .from('children')
  .select('*')
  .eq('id', childId)
  .maybeSingle();

if (!data) {
  console.log('Child not found');
  return;
}

// ❌ AVOID .single() - Throws error if not found
```

---

### INSERT Query

```typescript
const { data, error } = await supabase
  .from('user_progress')
  .insert({
    child_id: childId,
    lesson_id: lessonId,
    status: 'in_progress',
    score: null,
    time_spent_seconds: 0
  })
  .select()
  .single();

if (error) {
  console.error('Insert error:', error);
  return;
}

console.log('Created progress:', data);
```

**Best Practices:**
- Always `.select()` after insert to get created data
- Use `.single()` after `.select()` for single inserts
- Include required fields (check database schema)
- Let database handle defaults (created_at, updated_at)

---

### UPDATE Query

```typescript
const { data, error } = await supabase
  .from('user_progress')
  .update({
    status: 'completed',
    score: 95,
    completed_at: new Date().toISOString()
  })
  .eq('id', progressId)
  .select()
  .single();
```

---

### DELETE Query

```typescript
const { error } = await supabase
  .from('children')
  .delete()
  .eq('id', childId);

if (error) {
  console.error('Delete error:', error);
  toast.error('Failed to delete child');
  return;
}

toast.success('Child deleted successfully');
```

---

### COUNT Query

```typescript
const { count, error } = await supabase
  .from('user_progress')
  .select('*', { count: 'exact', head: true })
  .eq('child_id', childId)
  .eq('status', 'completed');

console.log('Completed lessons:', count);
```

---

### Aggregate Queries

```typescript
// Sum total points
const { data } = await supabase
  .rpc('calculate_total_points', {
    p_child_id: childId
  });

console.log('Total points:', data);
```

**Note:** Complex aggregations should use database functions (see DATABASE_SCHEMA.md)

---

## RLS (Row Level Security) Validation

### How RLS Works
Every query is automatically filtered by RLS policies. The `auth.uid()` function identifies the logged-in user.

**Example Policy:**
```sql
CREATE POLICY "Parents can view their children"
ON children FOR SELECT
USING (parent_id = auth.uid());
```

**Query Behavior:**
```typescript
// User A logged in (user-id-123)
const { data } = await supabase.from('children').select('*');

// Result: Only children where parent_id='user-id-123'
// RLS automatically filters - no WHERE clause needed!
```

---

### Bypassing RLS (Service Role)
**⚠️ ONLY use in Edge Functions with service role key**

```typescript
// In edge function
const supabase = createClient(
  Deno.env.get('SUPABASE_URL')!,
  Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!, // Bypasses RLS
  {
    auth: {
      autoRefreshToken: false,
      persistSession: false
    }
  }
);

// Now queries bypass RLS - use with extreme caution!
```

---

## Error Handling

### Standard Error Pattern

```typescript
const { data, error } = await supabase
  .from('lessons')
  .select('*')
  .eq('id', lessonId)
  .maybeSingle();

if (error) {
  console.error('Database error:', error);
  toast.error('Failed to load lesson. Please try again.');
  return;
}

if (!data) {
  toast.error('Lesson not found');
  navigate('/lessons');
  return;
}

// Success - use data
```

---

### Error Types

**1. Network Errors**
```typescript
if (error?.message.includes('fetch')) {
  toast.error('Network error. Check your connection.');
}
```

**2. Permission Errors (RLS)**
```typescript
if (error?.code === 'PGRST116') {
  toast.error('Unauthorized access');
  navigate('/login');
}
```

**3. Constraint Violations**
```typescript
if (error?.code === '23505') {
  toast.error('Duplicate entry. This already exists.');
}
```

**4. Foreign Key Violations**
```typescript
if (error?.code === '23503') {
  toast.error('Referenced record not found');
}
```

---

### User-Friendly Error Messages

```typescript
const getErrorMessage = (error: any): string => {
  if (error?.code === '23505') {
    return 'This item already exists';
  }
  if (error?.code === 'PGRST116') {
    return 'You do not have permission to access this';
  }
  if (error?.message?.includes('JWT')) {
    return 'Your session has expired. Please log in again.';
  }
  return 'An unexpected error occurred. Please try again.';
};

// Usage
if (error) {
  toast.error(getErrorMessage(error));
}
```

---

## React Query Integration

### Basic Query Hook

```typescript
import { useQuery } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';

const useLessons = (gradeLevel: number) => {
  return useQuery({
    queryKey: ['lessons', gradeLevel],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('lessons')
        .select('*')
        .eq('grade_level', gradeLevel)
        .eq('is_active', true);
      
      if (error) throw error;
      return data;
    },
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
};

// Usage
const MyComponent = () => {
  const { data: lessons, isLoading, error } = useLessons(2);

  if (isLoading) return <LoadingSpinner />;
  if (error) return <Alert variant="destructive">{error.message}</Alert>;

  return <LessonList lessons={lessons} />;
};
```

---

### Mutation Hook

```typescript
import { useMutation, useQueryClient } from '@tanstack/react-query';

const useCreateChild = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (childData: ChildInsert) => {
      const { data, error } = await supabase
        .from('children')
        .insert(childData)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      // Invalidate and refetch
      queryClient.invalidateQueries({ queryKey: ['children'] });
      toast.success('Child added successfully!');
    },
    onError: (error) => {
      console.error('Error creating child:', error);
      toast.error('Failed to add child');
    }
  });
};

// Usage
const MyComponent = () => {
  const { mutate: createChild, isPending } = useCreateChild();

  const handleSubmit = (data: ChildInsert) => {
    createChild(data);
  };

  return (
    <Button onClick={() => handleSubmit(childData)} disabled={isPending}>
      {isPending ? 'Adding...' : 'Add Child'}
    </Button>
  );
};
```

---

### Query Invalidation

```typescript
// Invalidate specific query
queryClient.invalidateQueries({ queryKey: ['children'] });

// Invalidate multiple queries
queryClient.invalidateQueries({ queryKey: ['children', childId] });
queryClient.invalidateQueries({ queryKey: ['user_progress', childId] });

// Refetch immediately
queryClient.refetchQueries({ queryKey: ['children'] });
```

---

### Optimistic Updates

```typescript
const useUpdateChild = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ id, ...updates }: ChildUpdate & { id: string }) => {
      const { data, error } = await supabase
        .from('children')
        .update(updates)
        .eq('id', id)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onMutate: async (updatedChild) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['children', updatedChild.id] });

      // Snapshot previous value
      const previousChild = queryClient.getQueryData(['children', updatedChild.id]);

      // Optimistically update
      queryClient.setQueryData(['children', updatedChild.id], updatedChild);

      return { previousChild };
    },
    onError: (err, updatedChild, context) => {
      // Rollback on error
      queryClient.setQueryData(['children', updatedChild.id], context?.previousChild);
      toast.error('Update failed');
    },
    onSettled: (data) => {
      // Refetch after error or success
      queryClient.invalidateQueries({ queryKey: ['children', data?.id] });
    }
  });
};
```

---

## Real-Time Subscriptions

### Subscribe to Table Changes

```typescript
import { useEffect } from 'react';

const useRealtimeMessages = (childId: string) => {
  const queryClient = useQueryClient();

  useEffect(() => {
    const channel = supabase
      .channel(`messages:${childId}`)
      .on(
        'postgres_changes',
        {
          event: 'INSERT',
          schema: 'public',
          table: 'parent_child_messages',
          filter: `child_id=eq.${childId}`
        },
        (payload) => {
          console.log('New message:', payload.new);
          
          // Invalidate messages query to refetch
          queryClient.invalidateQueries({ queryKey: ['messages', childId] });
          
          // Or manually update cache
          queryClient.setQueryData(['messages', childId], (old: any[]) => {
            return [...old, payload.new];
          });
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [childId, queryClient]);
};
```

---

### Subscribe to Multiple Events

```typescript
const channel = supabase
  .channel('collaboration_requests')
  .on(
    'postgres_changes',
    {
      event: 'INSERT',
      schema: 'public',
      table: 'collaboration_requests',
      filter: `recipient_child_id=eq.${childId}`
    },
    (payload) => {
      toast.info('New collaboration request!');
      queryClient.invalidateQueries({ queryKey: ['collaboration_requests'] });
    }
  )
  .on(
    'postgres_changes',
    {
      event: 'UPDATE',
      schema: 'public',
      table: 'collaboration_requests',
      filter: `requester_child_id=eq.${childId}`
    },
    (payload) => {
      if (payload.new.status === 'accepted') {
        toast.success('Your collaboration request was accepted!');
      }
    }
  )
  .subscribe();
```

---

### Broadcast Messages (Peer-to-Peer)

```typescript
// Sender
const sendPresence = async () => {
  const channel = supabase.channel('room:123');
  
  await channel.send({
    type: 'broadcast',
    event: 'user_joined',
    payload: { userId, userName }
  });
};

// Receiver
const channel = supabase.channel('room:123');

channel.on('broadcast', { event: 'user_joined' }, (payload) => {
  console.log('User joined:', payload);
  toast.info(`${payload.userName} joined the activity`);
});

channel.subscribe();
```

---

## Edge Function Integration

### Calling Edge Functions

```typescript
import { supabase } from '@/integrations/supabase/client';

const generateCustomLesson = async (
  childId: string,
  topic: string,
  subject: string,
  gradeLevel: number
) => {
  const { data, error } = await supabase.functions.invoke('generate-custom-lesson', {
    body: {
      childId,
      topic,
      subject,
      gradeLevel
    }
  });

  if (error) {
    console.error('Edge function error:', error);
    throw error;
  }

  return data;
};
```

---

### With React Query

```typescript
const useGenerateLesson = () => {
  return useMutation({
    mutationFn: async (params: {
      childId: string;
      topic: string;
      subject: string;
      gradeLevel: number;
    }) => {
      const { data, error } = await supabase.functions.invoke('generate-custom-lesson', {
        body: params
      });

      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      toast.success('Lesson generated!');
      navigate(`/lessons/${data.lessonId}`);
    },
    onError: (error: any) => {
      if (error.message?.includes('limit reached')) {
        toast.error('Daily custom lesson limit reached. Try again tomorrow!');
      } else {
        toast.error('Failed to generate lesson');
      }
    }
  });
};
```

---

### Error Handling for Edge Functions

```typescript
const { data, error } = await supabase.functions.invoke('my-function', {
  body: { param: 'value' }
});

if (error) {
  // Check error type
  if (error.message?.includes('429')) {
    toast.error('Rate limit exceeded. Please wait.');
  } else if (error.message?.includes('401')) {
    toast.error('Authentication failed');
    navigate('/login');
  } else {
    toast.error('Server error. Please try again.');
  }
  return;
}
```

---

## Database Functions (RPC)

### Calling Database Functions

```typescript
// Simple function call
const { data, error } = await supabase.rpc('calculate_streak', {
  p_child_id: childId
});

console.log('Current streak:', data);

// Function with multiple parameters
const { data: quotaStatus } = await supabase.rpc('check_platform_lesson_quota', {
  p_child_id: childId
});

console.log('Quota:', quotaStatus);
```

---

### With React Query

```typescript
const useStreak = (childId: string) => {
  return useQuery({
    queryKey: ['streak', childId],
    queryFn: async () => {
      const { data, error } = await supabase.rpc('calculate_streak', {
        p_child_id: childId
      });

      if (error) throw error;
      return data as number;
    },
    staleTime: 60 * 1000, // 1 minute
  });
};
```

---

## Authentication Integration

### Get Current User

```typescript
const { data: { user } } = await supabase.auth.getUser();

if (!user) {
  navigate('/login');
  return;
}

console.log('User ID:', user.id);
console.log('Email:', user.email);
```

---

### Auth State Listener

```typescript
useEffect(() => {
  const { data: { subscription } } = supabase.auth.onAuthStateChange(
    (event, session) => {
      if (event === 'SIGNED_IN') {
        console.log('User signed in:', session?.user);
        navigate('/dashboard');
      } else if (event === 'SIGNED_OUT') {
        console.log('User signed out');
        navigate('/login');
      }
    }
  );

  return () => subscription.unsubscribe();
}, []);
```

---

### Using useAuth Hook

```typescript
import { useAuth } from '@/hooks/useAuth';

const MyComponent = () => {
  const { user, isLoading } = useAuth();

  if (isLoading) return <LoadingSpinner />;
  
  if (!user) {
    navigate('/login');
    return null;
  }

  return <div>Welcome, {user.email}</div>;
};
```

---

## File Upload (Storage)

**Note:** Storage not yet implemented in Inner Odyssey. This is for future reference.

### Upload File

```typescript
const uploadAvatar = async (file: File, userId: string) => {
  const fileExt = file.name.split('.').pop();
  const fileName = `${userId}.${fileExt}`;
  const filePath = `avatars/${fileName}`;

  const { error } = await supabase.storage
    .from('avatars')
    .upload(filePath, file, {
      cacheControl: '3600',
      upsert: true
    });

  if (error) {
    throw error;
  }

  // Get public URL
  const { data } = supabase.storage
    .from('avatars')
    .getPublicUrl(filePath);

  return data.publicUrl;
};
```

---

### Download File

```typescript
const downloadFile = async (filePath: string) => {
  const { data, error } = await supabase.storage
    .from('avatars')
    .download(filePath);

  if (error) throw error;

  return data; // Blob
};
```

---

## Performance Optimization

### Query Optimization

✅ **DO:**
```typescript
// Only select needed columns
const { data } = await supabase
  .from('lessons')
  .select('id, title, subject')
  .eq('grade_level', 2);
```

❌ **DON'T:**
```typescript
// Don't select all columns if not needed
const { data } = await supabase
  .from('lessons')
  .select('*')
  .eq('grade_level', 2);
```

---

### Pagination

```typescript
const ITEMS_PER_PAGE = 20;

const { data, error, count } = await supabase
  .from('lessons')
  .select('*', { count: 'exact' })
  .range(page * ITEMS_PER_PAGE, (page + 1) * ITEMS_PER_PAGE - 1)
  .order('created_at', { ascending: false });

const totalPages = Math.ceil(count / ITEMS_PER_PAGE);
```

---

### React Query Stale Time

```typescript
// Data that changes frequently (real-time messages)
useQuery({
  queryKey: ['messages'],
  queryFn: fetchMessages,
  staleTime: 0, // Always refetch
});

// Data that rarely changes (lessons)
useQuery({
  queryKey: ['lessons'],
  queryFn: fetchLessons,
  staleTime: 10 * 60 * 1000, // 10 minutes
});

// Static data (badges)
useQuery({
  queryKey: ['badges'],
  queryFn: fetchBadges,
  staleTime: Infinity, // Never refetch automatically
});
```

---

### Debounced Queries

```typescript
import { useDebouncedValue } from '@/hooks/useDebouncedValue';

const MyComponent = () => {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearch = useDebouncedValue(searchTerm, 300);

  const { data: results } = useQuery({
    queryKey: ['search', debouncedSearch],
    queryFn: () => searchLessons(debouncedSearch),
    enabled: debouncedSearch.length > 2,
  });

  return (
    <Input
      value={searchTerm}
      onChange={(e) => setSearchTerm(e.target.value)}
      placeholder="Search lessons..."
    />
  );
};
```

---

## Best Practices Summary

### ✅ DO
1. Use React Query for all data fetching
2. Handle loading and error states
3. Use `.maybeSingle()` instead of `.single()`
4. Select only needed columns
5. Implement proper error messages for users
6. Invalidate queries after mutations
7. Use TypeScript types from schema
8. Implement pagination for large lists
9. Use real-time subscriptions sparingly
10. Test RLS policies thoroughly

### ❌ DON'T
1. Edit `client.ts` or `types.ts` (auto-generated)
2. Hardcode user IDs (use `auth.uid()`)
3. Trust client-side validation alone
4. Fetch all columns with `select('*')`
5. Ignore error handling
6. Make sequential queries when parallel is possible
7. Use `.single()` for queries that might return nothing
8. Store sensitive data in localStorage
9. Bypass RLS in client-side code
10. Make too many real-time subscriptions

---

## Troubleshooting

### Issue: "Invalid API key"
**Solution:** Check environment variables are set correctly.

### Issue: "Row level security policy violation"
**Solution:** Verify RLS policies allow the action. Test with `SET request.jwt.claims`.

### Issue: "JWT expired"
**Solution:** Supabase auto-refreshes tokens. If error persists, force logout/login.

### Issue: "Network request failed"
**Solution:** Check internet connection. Verify Supabase project status.

### Issue: "Column does not exist"
**Solution:** Database schema changed. Regenerate types and update queries.

### Issue: "Too many open connections"
**Solution:** Ensure subscriptions are cleaned up in useEffect return.

---

## Additional Resources

- [Supabase JS Client Docs](https://supabase.com/docs/reference/javascript/introduction)
- [React Query Docs](https://tanstack.com/query/latest/docs/framework/react/overview)
- [Row Level Security Guide](https://supabase.com/docs/guides/auth/row-level-security)
- Database Schema: `docs/DATABASE_SCHEMA.md`
- Edge Functions: `docs/EDGE_FUNCTIONS.md`
